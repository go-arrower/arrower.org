"use strict";(self.webpackChunkarrower_org=self.webpackChunkarrower_org||[]).push([[439],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=u(n),d=r,m=c["".concat(l,".").concat(d)]||c[d]||b[d]||o;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:r,i[1]=s;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7736:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>b,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:1},i="Jobs",s={unversionedId:"basics/jobs/index",id:"basics/jobs/index",title:"Jobs",description:"For everything that has to run in the background",source:"@site/docs/basics/03-jobs/index.md",sourceDirName:"basics/03-jobs",slug:"/basics/jobs/",permalink:"/docs/basics/jobs/",draft:!1,editUrl:"https://github.com/go-arrower/arrower.org/tree/master/docs/basics/03-jobs/index.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Views",permalink:"/docs/basics/views/"},next:{title:"Repeating Tasks",permalink:"/docs/basics/repeating-tasks/"}},l={},u=[{value:"Interface and Characteristics",id:"interface-and-characteristics",level:2},{value:"Enqueue Jobs",id:"enqueue-jobs",level:2},{value:"Scheduling Jobs",id:"scheduling-jobs",level:3},{value:"Prioritising Jobs",id:"prioritising-jobs",level:3},{value:"Inserting Jobs into the Database",id:"inserting-jobs-into-the-database",level:3},{value:"Process Jobs",id:"process-jobs",level:2},{value:"Different Queues",id:"different-queues",level:2},{value:"Testing",id:"testing",level:2},{value:"UI &amp; Observability",id:"ui--observability",level:2}],p={toc:u},c="wrapper";function b(e){let{components:t,...o}=e;return(0,r.kt)(c,(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"jobs"},"Jobs"),(0,r.kt)("p",null,"For everything that has to run in the background\n(asynchronous): jobs, tasks, long-running operations, bulk processing,\ncleanups, notifications, ect.\nIt is focused on developer convenience and creating a DDD and Clean Architecture oriented application\nthat is easy to understand, extend, and maintain. There is no need to mix serialisation logic within your domain layer."),(0,r.kt)("p",null,"Works with Postgres to keep the stack of the application small."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The use of PostgreSQL will have very serious implications on what is realistically possible with this setup\nin terms of scale but probably totally fine for a small to medium-sized app.")),(0,r.kt)("h2",{id:"interface-and-characteristics"},"Interface and Characteristics"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type Enqueuer interface {\n    Enqueue(context.Context, Job, ...JobOpt) error\n}\n\ntype Queue interface {\n    Enqueuer\n\n    RegisterJobFunc(func (ctx context.Context, job Job) error) error\n    Shutdown(context.Context) error\n}\n")),(0,r.kt)("p",null,"Key characteristics"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Exactly once guarantee for jobs (no need to deal with distributed transactions or 2X protocolls)"),(0,r.kt)("li",{parentName:"ul"},"Scheduling of jobs"),(0,r.kt)("li",{parentName:"ul"},"Automatic retries on job or worker failure"),(0,r.kt)("li",{parentName:"ul"},"Different Queues"),(0,r.kt)("li",{parentName:"ul"},"Different priorities per queue"),(0,r.kt)("li",{parentName:"ul"},"Visibility into the queues and jobs statuses"),(0,r.kt)("li",{parentName:"ul"},"List current workers per queue")),(0,r.kt)("h2",{id:"enqueue-jobs"},"Enqueue Jobs"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"var jq jobs.Enqueuer\n\n// enqueue a single job\n_ = jq.Enqueue(ctx, myJob{Payload: 1})\n\n// enqueue multiple jobs\n_ = jq.Enqueue(ctx, []myJob{{Payload: 1}, {Payload: 2}})\n\n// enqueue multiple jobs of different kinds\n_ = jq.Enqueue(ctx, []any{myJob{Payload: 1}, otherJob{}})\n")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/go-arrower/arrower/blob/master/jobs/jobs.business_test.go"},"See working example")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If the ",(0,r.kt)("inlineCode",{parentName:"li"},"ctx")," contains a transaction, it is used to persist the job to the database.\nKeeping your job consistent with your application data.")),(0,r.kt)("h3",{id:"scheduling-jobs"},"Scheduling Jobs"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"_ = jq.Enqueue(ctx, myJob{}, jobs.WithRunAt(time.Now().Add(10*time.Minute)))\n")),(0,r.kt)("h3",{id:"prioritising-jobs"},"Prioritising Jobs"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// a lower number means a higher priority\n_ = jq.Enqueue(ctx, myJob{}, jobs.WithPriority(-1))\n")),(0,r.kt)("h3",{id:"inserting-jobs-into-the-database"},"Inserting Jobs into the Database"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO arrower.gue_jobs(job_id, created_at, updated_at, run_at, queue, job_type, priority, args)\nVALUES (generate_ulid(), now(), now(), now(),\n        '', 'MyJob', 0,\n        (json_build_object(\n            'jobData', '{}'\n         ) #>> '{}')::BYTEA -- JSON can not be converted to BYTEA: convert to TEXT first\n        );\n")),(0,r.kt)("h2",{id:"process-jobs"},"Process Jobs"),(0,r.kt)("p",null,"Each job is processed asynchronously in its own worker go routine.\nTo be able to process jobs it is important to register a ",(0,r.kt)("inlineCode",{parentName:"p"},"JobFunc")," on the appropriate queue."),(0,r.kt)("p",null,"The function has to have the signature of ",(0,r.kt)("inlineCode",{parentName:"p"},"func(ctx context.Context, job YourJobType) error")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"var jq jobs.Queue\n\n_ = jq.RegisterJobFunc(func(ctx context.Context, job myJob) error {\n    // process your job here...\n    \n    return nil\n}) \n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Returning an error will reschedule the job with an exponential backoff"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"ctx")," contains a transaction the job is running inside, so you can keep all your operations consistent",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tx, txOk := ctx.Value(postgres.CtxTX).(pgx.Tx)")))),(0,r.kt)("li",{parentName:"ul"},"A call to ",(0,r.kt)("inlineCode",{parentName:"li"},"RegisterJobFunc")," does start the worker pool after a certain time. If the worker poll got started already,\nsubsequent calls to ",(0,r.kt)("inlineCode",{parentName:"li"},"RegisterJobFunc")," will shut it down and restart it automatically blocking your call for that time.")),(0,r.kt)("h2",{id:"different-queues"},"Different Queues"),(0,r.kt)("p",null,"Arrower supports multiple job queues, but each queue has to be instantiated. If no explicit queue name is\nset, the default queue is used."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'jq, err := jobs.NewPostgresJobs(alog.NewNoopLogger(), noop.NewMeterProvider(), noop.NewTracerProvider(), pgHandler.PGx,\n    jobs.WithQueue("queueName"), // set the name of the queue you want to run\n)\n')),(0,r.kt)("p",null,"Each queue can be configured with these optional options. "),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Option"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Behaviour"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"WithQueue")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<empty>")),(0,r.kt)("td",{parentName:"tr",align:null},"Set the name of the queue")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"WithPollInterval")),(0,r.kt)("td",{parentName:"tr",align:null},"5 seconds"),(0,r.kt)("td",{parentName:"tr",align:null},"Set the interval to query the database for new jobs.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"WithPoolSize")),(0,r.kt)("td",{parentName:"tr",align:null},"10"),(0,r.kt)("td",{parentName:"tr",align:null},"Set the amount of workers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"WithPoolName")),(0,r.kt)("td",{parentName:"tr",align:null},"a random name"),(0,r.kt)("td",{parentName:"tr",align:null},"Set the a name for this worker pool instance")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"WithWorkerPollStrategy")),(0,r.kt)("td",{parentName:"tr",align:null},"PriorityPollStrategy"),(0,r.kt)("td",{parentName:"tr",align:null},"Set the  poll strategy")))),(0,r.kt)("p",null,"The queue is instrumented to give you ",(0,r.kt)("a",{parentName:"p",href:"./observability"},"observability")," out of the box.\nYou'll have logs, metrics, and traces available for you."),(0,r.kt)("h2",{id:"testing"},"Testing"),(0,r.kt)("p",null,"As the Job's handlers are just functions you can test them normally, like you would do anyway."),(0,r.kt)("p",null,"What is remaining is to ensure the right Jobs get enqueued on the emitting site.\nFor this an in memory implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"jobs.Queue")," interface is available, you can use in tests. It comes\nwith some additional methods, to make testing easier:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Custom assertions for the job queue")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"  jq := jobs.NewTestingJobs()\n  jassert := jq.Assert(t)\n\n  // asserts the queue is empty\n  jassert.Empty()\n\n  _ = jq.Enqueue(ctx, myJob{})\n\n  // asserts the queue is not empty\n  jassert.NotEmpty()\n\n  // asserts the queue has exactly one Job of type `myJob`\n  jassert.Queued(myJob{}, 1)\n\n  // asserts the queue has 1 Job enqueued\n  jassert.QueuedTotal(1)\n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Custom test helpers beyond the ",(0,r.kt)("inlineCode",{parentName:"li"},"jobs.Queue")," interface")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'  jq := jobs.NewTestingJobs()\n\n  // get a Job without processing it, to assert Job details.\n  job := queue.GetFirstOf(myJob{}).(myJob)\n  assert.Equal(t, "myName", job.Name)\n\n  // resets the queue to be empty\n  jq.Reset() \n')),(0,r.kt)("h2",{id:"ui--observability"},"UI & Observability"),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"/docs/basics/observability"},"Observability for more details")),(0,r.kt)("img",{src:n(7866).Z}),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Jobs integrate with the observability setup of arrower"),(0,r.kt)("li",{parentName:"ul"},"The originating span is persisted and referenced in each Job run"),(0,r.kt)("li",{parentName:"ul"},"Failing Job runs are marked and retried automatically")))}b.isMDXComponent=!0},7866:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/queue-otel-tracing-413652944366e601807e6c64be9c2c2d.png"}}]);