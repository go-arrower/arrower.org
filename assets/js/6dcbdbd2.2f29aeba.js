"use strict";(self.webpackChunkarrower_org=self.webpackChunkarrower_org||[]).push([[904],{8370:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>T,contentTitle:()=>A,default:()=>N,frontMatter:()=>j,metadata:()=>U,toc:()=>k});var r=n(5893),o=n(1151),a=n(7294),s=n(6905),i=n(3735),c=n(6550),l=n(613),x=n(4423),u=n(636),d=n(5318);function p(t){return a.Children.toArray(t).filter((t=>"\n"!==t)).map((t=>{if(!t||(0,a.isValidElement)(t)&&function(t){const{props:e}=t;return!!e&&"object"==typeof e&&"value"in e}(t))return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function I(t){const{values:e,children:n}=t;return(0,a.useMemo)((()=>{const t=e??function(t){return p(t).map((t=>{let{props:{value:e,label:n,attributes:r,default:o}}=t;return{value:e,label:n,attributes:r,default:o}}))}(n);return function(t){const e=(0,u.l)(t,((t,e)=>t.value===e.value));if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[e,n])}function D(t){let{value:e,tabValues:n}=t;return n.some((t=>t.value===e))}function h(t){let{queryString:e=!1,groupId:n}=t;const r=(0,c.k6)(),o=function(t){let{queryString:e=!1,groupId:n}=t;if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,x._X)(o),(0,a.useCallback)((t=>{if(!o)return;const e=new URLSearchParams(r.location.search);e.set(o,t),r.replace({...r.location,search:e.toString()})}),[o,r])]}function m(t){const{defaultValue:e,queryString:n=!1,groupId:r}=t,o=I(t),[s,i]=(0,a.useState)((()=>function(t){let{defaultValue:e,tabValues:n}=t;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!D({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const r=n.find((t=>t.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:e,tabValues:o}))),[c,x]=h({queryString:n,groupId:r}),[u,p]=function(t){let{groupId:e}=t;const n=function(t){return t?`docusaurus.tab.${t}`:null}(e),[r,o]=(0,d.Nk)(n);return[r,(0,a.useCallback)((t=>{n&&o.set(t)}),[n,o])]}({groupId:r}),m=(()=>{const t=c??u;return D({value:t,tabValues:o})?t:null})();(0,l.Z)((()=>{m&&i(m)}),[m]);return{selectedValue:s,selectValue:(0,a.useCallback)((t=>{if(!D({value:t,tabValues:o}))throw new Error(`Can't select invalid tab value=${t}`);i(t),x(t),p(t)}),[x,p,o]),tabValues:o}}var y=n(5730);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function C(t){let{className:e,block:n,selectedValue:o,selectValue:a,tabValues:c}=t;const l=[],{blockElementScrollPositionUntilNextRender:x}=(0,i.o5)(),u=t=>{const e=t.currentTarget,n=l.indexOf(e),r=c[n].value;r!==o&&(x(e),a(r))},d=t=>{let e=null;switch(t.key){case"Enter":u(t);break;case"ArrowRight":{const n=l.indexOf(t.currentTarget)+1;e=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(t.currentTarget)-1;e=l[n]??l[l.length-1];break}}e?.focus()};return(0,r.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":n},e),children:c.map((t=>{let{value:e,label:n,attributes:a}=t;return(0,r.jsx)("li",{role:"tab",tabIndex:o===e?0:-1,"aria-selected":o===e,ref:t=>l.push(t),onKeyDown:d,onClick:u,...a,className:(0,s.Z)("tabs__item",b.tabItem,a?.className,{"tabs__item--active":o===e}),children:n??e},e)}))})}function f(t){let{lazy:e,children:n,selectedValue:o}=t;const s=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const t=s.find((t=>t.props.value===o));return t?(0,a.cloneElement)(t,{className:"margin-top--md"}):null}return(0,r.jsx)("div",{className:"margin-top--md",children:s.map(((t,e)=>(0,a.cloneElement)(t,{key:e,hidden:t.props.value!==o})))})}function g(t){const e=m(t);return(0,r.jsxs)("div",{className:(0,s.Z)("tabs-container",b.tabList),children:[(0,r.jsx)(C,{...e,...t}),(0,r.jsx)(f,{...e,...t})]})}function E(t){const e=(0,y.Z)();return(0,r.jsx)(g,{...t,children:p(t.children)},String(e))}const v={tabItem:"tabItem_Ymn6"};function w(t){let{children:e,hidden:n,className:o}=t;return(0,r.jsx)("div",{role:"tabpanel",className:(0,s.Z)(v.tabItem,o),hidden:n,children:e})}const j={},A="Database",U={id:"basics/database/index",title:"Database",description:"Arrower only works with Postgres.",source:"@site/docs/basics/03-database/index.md",sourceDirName:"basics/03-database",slug:"/basics/database/",permalink:"/docs/basics/database/",draft:!1,unlisted:!1,editUrl:"https://github.com/go-arrower/arrower.org/tree/master/docs/basics/03-database/index.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Views",permalink:"/docs/basics/views/"},next:{title:"Usecases",permalink:"/docs/basics/usecases/"}},T={},k=[];function R(t){const e={code:"code",h1:"h1",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...t.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h1,{id:"database",children:"Database"}),"\n",(0,r.jsx)(e.p,{children:"Arrower only works with Postgres."}),"\n",(0,r.jsx)(e.p,{children:"Arrower uses the pgx driver. In principle, you can use another one for your application."}),"\n",(0,r.jsx)(e.p,{children:"Arrower does not offer any database abstraction. The Go community does not settle on any standard.\nYou can go with whatever you want, e.g."}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"sqlx"}),"\n",(0,r.jsx)(e.li,{children:"gorm"}),"\n",(0,r.jsx)(e.li,{children:"sqlc"}),"\n",(0,r.jsx)(e.li,{children:"sqlboiler"}),"\n",(0,r.jsx)(e.li,{children:"ent"}),"\n",(0,r.jsx)(e.li,{children:"..."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Arrower recommends the Repository pattern for all database access,\nso that the domain model is not coupled to the database model.\nIt also makes it easy to test the application with an in memory repository."}),"\n",(0,r.jsx)(e.p,{children:"The approach arrower is taking:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"the repository represents actions from the domain => FindByLoginName()"}),"\n",(0,r.jsxs)(e.li,{children:["as repository has to be implemented each time there is a helper:","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"the following interfaces are provided as in memory and pg implementation"}),"\n",(0,r.jsx)(e.li,{children:"extend and overwrite them to fit them to your domain"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",metastring:'title="Direct use of generic repository"',children:"// define the repository in the domain \ntype UserRepository interface {\n    Save(ctx context.Context, user User) error\n    FindByID(ctx context.Context, id UserID) (User, error)\n    Delete(ctx context.Context, user User) error\n}\n\n// usage in your application\nvar repo UserRepository = repository.NewMemoryRepository[User, UserID](),\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",metastring:'title="Wrap the generic repository"',children:"// define the repository in the domain \ntype UserRepository interface {\n    Save(ctx context.Context, user User) error\n    FindByID(ctx context.Context, id UserID) (User, error)\n    Delete(ctx context.Context, user User) error\n}\n\n// implement the repository in the interfaces layer\nfunc NewInMemoryUserRepository() *InMemoryUserRepository {\n    return &InMemoryUserRepository{\n        MemoryRepository: repository.NewMemoryRepository[User, UserID](),\n    }\n}\n\nvar _ UserRepository = (*InMemoryUserRepository)(nil)\n\ntype InMemoryUserRepository struct {\n    *repository.MemoryRepository[User, UserID]\n}\n\n// usage in your application\nvar repo UserRepository = NewInMemoryUserRepository()\n"})}),"\n",(0,r.jsxs)(e.p,{children:["As simple repositories share a repeating set of methods,\nArrower offers commonly used methods ready out of the box.\nIn general, it is good practise to keep your own repository methods to a minimum.\nArrower offers a lot for your convenience,\n",(0,r.jsx)(e.strong,{children:"not"})," as a recommendation to use all of them at all times!"]}),"\n","\n",(0,r.jsxs)(E,{children:[(0,r.jsx)(w,{value:"entity",label:"Entity Repository",default:!0,children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",metastring:'title="inmemory.repository.go"',children:"type Repository[E any, ID id] interface {\n    NextID(ctx context.Context) (ID, error)\n\n    Create(ctx context.Context, entity E) error\n    Read(ctx context.Context, id ID) (E, error)\n    Update(ctx context.Context, entity E) error\n    Delete(ctx context.Context, entity E) error\n    \n    All(ctx context.Context) ([]E, error)\n    AllByIDs(ctx context.Context, ids []ID) ([]E, error)\n    FindAll(ctx context.Context) ([]E, error)\n    FindByID(ctx context.Context, id ID) (E, error)\n    FindByIDs(ctx context.Context, ids []ID) ([]E, error)\n    Exists(ctx context.Context, id ID) (bool, error)\n    ExistsByID(ctx context.Context, id ID) (bool, error)\n    ExistByIDs(ctx context.Context, ids []ID) (bool, error)\n    ExistAll(ctx context.Context, ids []ID) (bool, error)\n    Contains(ctx context.Context, id ID) (bool, error)\n    ContainsID(ctx context.Context, id ID) (bool, error)\n    ContainsIDs(ctx context.Context, ids []ID) (bool, error)\n    ContainsAll(ctx context.Context, ids []ID) (bool, error)\n    \n    Save(ctx context.Context, entity E) error\n    SaveAll(ctx context.Context, entities []E) error\n    UpdateAll(ctx context.Context, entities []E) error\n    Add(ctx context.Context, entity E) error\n    AddAll(ctx context.Context, entities []E) error\n    \n    Count(ctx context.Context) (int, error)\n    Length(ctx context.Context) (int, error)\n    Empty(ctx context.Context) (bool, error)\n    IsEmpty(ctx context.Context) (bool, error)\n    \n    DeleteByID(ctx context.Context, id ID) error\n    DeleteByIDs(ctx context.Context, ids []ID) error\n    DeleteAll(ctx context.Context) error\n    Clear(ctx context.Context) error\n}\n"})})}),(0,r.jsx)(w,{value:"tenant",label:"Tenant Repository",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",metastring:'title="inmemory.tenant.repository.go"',children:"type TenantRepository[T any, tID id, E any, eID id] interface {\n    NextID(ctx context.Context, tenantID tID) (eID, error)\n    \n    Create(ctx context.Context, tenantID tID, entity E) error\n    Read(ctx context.Context, tenantID tID, id eID) (E, error)\n    Update(ctx context.Context, tenantID tID, entity E) error\n    Delete(ctx context.Context, tenantID tID, entity E) error\n    \n    All(ctx context.Context) ([]E, error)\n    AllOfTenant(ctx context.Context, tenantID tID) ([]E, error)\n    AllByIDs(ctx context.Context, tenantID tID, ids []eID) ([]E, error)\n    FindAll(ctx context.Context) ([]E, error)\n    FindAllOfTenant(ctx context.Context, tenantID tID) ([]E, error)\n    FindByID(ctx context.Context, tenantID tID, id eID) (E, error)\n    FindByIDs(ctx context.Context, tenantID tID, ids []eID) ([]E, error)\n    Exists(ctx context.Context, tenantID tID, id eID) (bool, error)\n    ExistsByID(ctx context.Context, tenantID tID, id eID) (bool, error)\n    ExistByIDs(ctx context.Context, tenantID tID, ids []eID) (bool, error)\n    ExistAll(ctx context.Context, tenantID tID, ids []eID) (bool, error)\n    Contains(ctx context.Context, tenantID tID, id eID) (bool, error)\n    ContainsID(ctx context.Context, tenantID tID, id eID) (bool, error)\n    ContainsIDs(ctx context.Context, tenantID tID, ids []eID) (bool, error)\n    ContainsAll(ctx context.Context, tenantID tID, ids []eID) (bool, error)\n    \n    Save(ctx context.Context, tenantID tID, entity E) error\n    SaveAll(ctx context.Context, tenantID tID, entities []E) error\n    UpdateAll(ctx context.Context, tenantID tID, entities []E) error\n    Add(ctx context.Context, tenantID tID, entity E) error\n    AddAll(ctx context.Context, tenantID tID, entities []E) error\n    \n    Count(ctx context.Context) (int, error)\n    CountOfTenant(ctx context.Context, tenantID tID) (int, error)\n    Length(ctx context.Context) (int, error)\n    LengthOfTenant(ctx context.Context, tenantID tID) (int, error)\n    Empty(ctx context.Context) (bool, error)\n    EmptyTenant(ctx context.Context, tenantID tID) (bool, error)\n    IsEmpty(ctx context.Context) (bool, error)\n    IsEmptyTenant(ctx context.Context, tenantID tID) (bool, error)\n    \n    DeleteByID(ctx context.Context, tenantID tID, id eID) error\n    DeleteByIDs(ctx context.Context, tenantID tID, ids []eID) error\n    DeleteAll(ctx context.Context) error\n    DeleteAllOfTenant(ctx context.Context, tenantID tID) error\n    Clear(ctx context.Context) error\n    ClearTenant(ctx context.Context, tenantID tID) error\n}\n"})})})]})]})}function N(t={}){const{wrapper:e}={...(0,o.a)(),...t.components};return e?(0,r.jsx)(e,{...t,children:(0,r.jsx)(R,{...t})}):R(t)}},1151:(t,e,n)=>{n.d(e,{Z:()=>i,a:()=>s});var r=n(7294);const o={},a=r.createContext(o);function s(t){const e=r.useContext(a);return r.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function i(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(o):t.components||o:s(t.components),r.createElement(a.Provider,{value:e},t.children)}}}]);